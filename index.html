<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reptile Interactive Cursor</title>
  <style>
    :root {
      --bg: #0e1726;
      --fg: #c8d1e6;
      --accent: #86efac;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 70% 20%, #121f33, var(--bg));
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow: hidden;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
    .hint {
      position: fixed; inset: 0 auto auto 0; margin: 16px; padding: 10px 14px;
      background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px; backdrop-filter: blur(6px);
      user-select: none; pointer-events: none; font-size: 14px; line-height: 1.2;
    }
    .hint b { color: var(--accent); }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">
    <b>Reptile Cursor</b> â€” move your mouse / finger.<br>
    Left click: wiggle.  Middle: pause.  Right: reverse.
  </div>
  <script>
  // ===== Input helpers (matches the snippet from your screenshot) =====
  const Input = { mouse: { x: 0, y: 0, left: false, middle: false, right: false }, down:false };
  document.addEventListener("mousemove", (e) => { Input.mouse.x = e.clientX; Input.mouse.y = e.clientY; });
  document.addEventListener("mousedown", function(event) {
    if ((event.button == 0)) { Input.mouse.left = true; }
    if ((event.button == 1)) { Input.mouse.middle = true; }
    if ((event.button == 2)) { Input.mouse.right = true; }
    Input.down = true;
  });
  document.addEventListener("mouseup", function(event) {
    if ((event.button == 0)) { Input.mouse.left = false; }
    if ((event.button == 1)) { Input.mouse.middle = false; }
    if ((event.button == 2)) { Input.mouse.right = false; }
    Input.down = false;
  });
  // disable context menu so right click can be used interactively
  window.addEventListener('contextmenu', e => e.preventDefault());

  // ===== Canvas setup =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener('resize', resize, { passive: true });
  resize();

  // Touch support => treat first touch as mouse
  addEventListener('touchstart', (e) => {
    const t = e.touches[0];
    Input.mouse.x = t.clientX; Input.mouse.y = t.clientY; Input.mouse.left = true; Input.down = true;
  }, { passive: true });
  addEventListener('touchmove', (e) => {
    const t = e.touches[0];
    Input.mouse.x = t.clientX; Input.mouse.y = t.clientY;
  }, { passive: true });
  addEventListener('touchend', () => { Input.mouse.left = false; Input.down = false; }, { passive: true });

  // ===== Reptile model =====
  const SEGMENTS = 48;          // total vertebrae
  const SEG_LEN = 12;           // distance between vertebrae
  const BASE_RADIUS = 10;       // head radius (tail tapers)
  const LEG_LEN = 14;           // leg length
  const LEGS_EVERY = 1;         // draw legs for each segment (can use 2 to reduce)
  const WIGGLE_FREQ = 6.0;      // wiggle frequency
  const WIGGLE_MAG = 0.45;      // wiggle magnitude

  const body = Array.from({length: SEGMENTS}, (_, i) => ({ x: innerWidth*0.5, y: innerHeight*0.5, ang: 0 }));
  let t = 0;
  let reverse = false;
  let paused = false;

  function update(dt){
    // interactions
    if (Input.mouse.left) wiggleMag = WIGGLE_MAG; else wiggleMag = WIGGLE_MAG * 0.2;
    if (Input.mouse.middle && !pausedOnce){ paused = !paused; pausedOnce = true; } else if(!Input.mouse.middle){ pausedOnce = false; }
    if (Input.mouse.right && !reversedOnce){ reverse = !reverse; reversedOnce = true; } else if(!Input.mouse.right){ reversedOnce = false; }
    if (paused) return;

    // head eases toward pointer with slight wiggle
    const head = body[0];
    const dx = Input.mouse.x - head.x;
    const dy = Input.mouse.y - head.y;
    const dist = Math.hypot(dx, dy) || 1;
    const ease = Math.min(0.25, 120 / (dist + 200));
    const dir = Math.atan2(dy, dx);

    // add a sinusoidal wiggle perpendicular to direction
    const wobble = Math.sin(t * WIGGLE_FREQ) * wiggleMag;
    head.x += Math.cos(dir) * dist * ease + Math.cos(dir + Math.PI/2) * wobble;
    head.y += Math.sin(dir) * dist * ease + Math.sin(dir + Math.PI/2) * wobble;
    head.ang = dir;

    // inverse kinematics for the rest of the chain
    for (let i = 1; i < body.length; i++){
      const prev = body[i-1];
      const cur = body[i];
      const a = Math.atan2(cur.y - prev.y, cur.x - prev.x);
      const na = reverse ? a + 0.02 : a - 0.02; // slight bend for organic look
      cur.x = prev.x + Math.cos(na) * -SEG_LEN;
      cur.y = prev.y + Math.sin(na) * -SEG_LEN;
      cur.ang = na;
    }
  }

  let reversedOnce = false, pausedOnce = false, wiggleMag = WIGGLE_MAG * 0.2;

  function draw(){
    ctx.clearRect(0, 0, innerWidth, innerHeight);

    // soft glow trail
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (let i = 0; i < body.length; i++){
      const p = body[i];
      const r = BASE_RADIUS * (1 - i / body.length) * 0.9 + 3;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(134, 239, 172, 0.08)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();

    // spine
    ctx.beginPath();
    for (let i = 0; i < body.length; i++){
      const p = body[i];
      if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
    }
    ctx.strokeStyle = 'rgba(200, 209, 230, 0.22)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // vertebrae + legs
    for (let i = 0; i < body.length; i++){
      const p = body[i];
      const r = BASE_RADIUS * (1 - i / body.length) * 0.75 + 1.5;

      // vertebra (ring)
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(200, 209, 230, 0.55)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // little legs (alternating)
      if (i % LEGS_EVERY === 0){
        const nx = Math.cos(p.ang + Math.PI/2);
        const ny = Math.sin(p.ang + Math.PI/2);
        const phase = (i % 2 === 0 ? 1 : -1) * (Math.sin(t*WIGGLE_FREQ + i*0.3) * 0.4 + 0.6);
        const len = LEG_LEN * (1 - i / body.length) * phase;

        ctx.beginPath();
        ctx.moveTo(p.x + nx * (r*0.6), p.y + ny * (r*0.6));
        ctx.lineTo(p.x + nx * (r*0.6 + len), p.y + ny * (r*0.6 + len));
        ctx.moveTo(p.x - nx * (r*0.6), p.y - ny * (r*0.6));
        ctx.lineTo(p.x - nx * (r*0.6 + len), p.y - ny * (r*0.6 + len));
        ctx.strokeStyle = 'rgba(200, 209, 230, 0.45)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    // head detail (eyes)
    const h = body[0];
    const eyeOff = 4;
    const ex = Math.cos(h.ang + Math.PI/2) * eyeOff;
    const ey = Math.sin(h.ang + Math.PI/2) * eyeOff;
    ctx.beginPath();
    ctx.arc(h.x + ex, h.y + ey, 1.6, 0, Math.PI*2);
    ctx.arc(h.x - ex, h.y - ey, 1.6, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(134,239,172,0.9)';
    ctx.fill();
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.035, (now - last)/1000);
    last = now; t += dt;
    update(dt); draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  </script>
</body>
</html>



